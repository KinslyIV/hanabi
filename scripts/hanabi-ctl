#!/bin/bash
#
# hanabi-ctl - Control script for Hanabi training services
#
# Usage: hanabi-ctl <command> [options]
#

set -e

# Configuration - adjust these to match your setup
USER="${HANABI_USER:-$(whoami)}"
GPU_SERVICE="hanabi-gpu-server"
COORDINATOR_SERVICE="hanabi-coordinator"
CHECKPOINT_DIR="${HANABI_CHECKPOINT_DIR:-checkpoints}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[OK]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

usage() {
    cat << EOF
Hanabi Training Control Script

Usage: $(basename "$0") <command> [target]

Commands:
  status              Show status of all services
  start [target]      Start services (gpu, coordinator, or all)
  stop [target]       Graceful stop with checkpoint (gpu, coordinator, or all)
  restart [target]    Restart services (gpu, coordinator, or all)
  checkpoint [target] Save checkpoint without stopping (gpu, coordinator, or all)
  kill [target]       Force kill services (gpu, coordinator, or all)
  logs [target]       Follow logs (gpu, coordinator, or all)
  fresh               Reset training state for fresh start on next run
  help                Show this help message

Targets:
  gpu          GPU training server only
  coordinator  Training coordinator only
  all          Both services (default)

Examples:
  $(basename "$0") status              # Check status of all services
  $(basename "$0") checkpoint          # Save checkpoint on both services
  $(basename "$0") checkpoint gpu      # Save checkpoint on GPU server only
  $(basename "$0") stop                # Graceful stop all services
  $(basename "$0") logs coordinator    # Follow coordinator logs
  $(basename "$0") fresh               # Reset state for fresh start

Environment:
  HANABI_USER    Override the username for service names (default: current user)

Signals used:
  SIGTERM  - Graceful shutdown (saves checkpoint before exit)
  SIGUSR1  - Save checkpoint without stopping
  SIGKILL  - Force kill (no checkpoint, use as last resort)

Resume behavior:
  - If previous training COMPLETED: Next start begins fresh
  - If previous training was INTERRUPTED: Next start resumes
  - Use 'fresh' command to force fresh start after interrupted training

EOF
}

get_services() {
    local target="${1:-all}"
    case "$target" in
        gpu)
            echo "$GPU_SERVICE"
            ;;
        coordinator)
            echo "$COORDINATOR_SERVICE"
            ;;
        all)
            echo "$GPU_SERVICE $COORDINATOR_SERVICE"
            ;;
        *)
            print_error "Unknown target: $target (use gpu, coordinator, or all)"
            exit 1
            ;;
    esac
}

cmd_status() {
    echo -e "\n${BLUE}=== Hanabi Training Services Status ===${NC}\n"
    
    for service in $GPU_SERVICE $COORDINATOR_SERVICE; do
        echo -e "${YELLOW}Service: ${service}${NC}"
        if systemctl is-active --quiet "$service" 2>/dev/null; then
            echo -e "  Status: ${GREEN}● Running${NC}"
            # Get PID and memory usage
            pid=$(systemctl show -p MainPID --value "$service" 2>/dev/null)
            if [ -n "$pid" ] && [ "$pid" != "0" ]; then
                echo "  PID: $pid"
                if [ -f "/proc/$pid/status" ]; then
                    mem=$(awk '/VmRSS/ {print $2}' /proc/$pid/status 2>/dev/null)
                    if [ -n "$mem" ]; then
                        echo "  Memory: $((mem / 1024)) MB"
                    fi
                fi
            fi
        else
            echo -e "  Status: ${RED}○ Stopped${NC}"
        fi
        echo ""
    done
    
    # Show training state
    CHECKPOINT_DIR="${CHECKPOINT_DIR:-checkpoints}"
    STATE_FILE="$CHECKPOINT_DIR/training_state.json"
    
    if [ -f "$STATE_FILE" ]; then
        echo -e "${BLUE}=== Training State ===${NC}\n"
        
        ITER=$(jq -r '.iteration // 0' "$STATE_FILE" 2>/dev/null)
        TARGET=$(jq -r '.target_iterations // 0' "$STATE_FILE" 2>/dev/null)
        GAMES=$(jq -r '.total_games // 0' "$STATE_FILE" 2>/dev/null)
        STEPS=$(jq -r '.total_train_steps // 0' "$STATE_FILE" 2>/dev/null)
        COMPLETED=$(jq -r '.completed // false' "$STATE_FILE" 2>/dev/null)
        BEST=$(jq -r '.best_avg_score // 0' "$STATE_FILE" 2>/dev/null)
        
        echo "  Iteration:       $ITER / $TARGET"
        echo "  Total Games:     $GAMES"
        echo "  Total Steps:     $STEPS"
        echo "  Best Avg Score:  $BEST"
        
        if [ "$COMPLETED" = "true" ]; then
            echo -e "  Status:          ${GREEN}✓ COMPLETED${NC}"
            echo ""
            echo -e "  ${YELLOW}Next restart will begin fresh training.${NC}"
        else
            if [ "$ITER" -gt 0 ]; then
                echo -e "  Status:          ${YELLOW}⏸ INTERRUPTED${NC}"
                echo ""
                echo -e "  ${YELLOW}Next restart will resume from iteration $ITER.${NC}"
                echo -e "  ${YELLOW}Use 'hanabi-ctl fresh' to force fresh start.${NC}"
            else
                echo -e "  Status:          ${BLUE}○ NOT STARTED${NC}"
            fi
        fi
        echo ""
    fi
    
    # Show latest checkpoint
    if [ -d "$CHECKPOINT_DIR" ]; then
        LATEST=$(ls -t "$CHECKPOINT_DIR"/checkpoint_*.pt 2>/dev/null | head -1)
        if [ -n "$LATEST" ]; then
            echo -e "${BLUE}=== Latest Checkpoint ===${NC}\n"
            SIZE=$(du -h "$LATEST" | cut -f1)
            MTIME=$(stat -c %y "$LATEST" 2>/dev/null | cut -d. -f1)
            echo "  File: $(basename "$LATEST")"
            echo "  Size: $SIZE"
            echo "  Time: $MTIME"
            echo ""
        fi
    fi
}

cmd_start() {
    local target="${1:-all}"
    local services=$(get_services "$target")
    
    for service in $services; do
        print_status "Starting $service..."
        if sudo systemctl start "$service"; then
            print_success "$service started"
        else
            print_error "Failed to start $service"
        fi
    done
}

cmd_stop() {
    local target="${1:-all}"
    local services=$(get_services "$target")
    
    print_warning "This will gracefully stop training and save a final checkpoint"
    
    for service in $services; do
        print_status "Stopping $service (saving checkpoint)..."
        if sudo systemctl stop "$service"; then
            print_success "$service stopped"
        else
            print_error "Failed to stop $service"
        fi
    done
}

cmd_restart() {
    local target="${1:-all}"
    local services=$(get_services "$target")
    
    for service in $services; do
        print_status "Restarting $service..."
        if sudo systemctl restart "$service"; then
            print_success "$service restarted"
        else
            print_error "Failed to restart $service"
        fi
    done
}

cmd_checkpoint() {
    local target="${1:-all}"
    local services=$(get_services "$target")
    
    for service in $services; do
        if systemctl is-active --quiet "$service" 2>/dev/null; then
            print_status "Saving checkpoint for $service..."
            if sudo systemctl kill --signal=SIGUSR1 "$service"; then
                print_success "Checkpoint signal sent to $service"
            else
                print_error "Failed to send checkpoint signal to $service"
            fi
        else
            print_warning "$service is not running, skipping"
        fi
    done
    
    echo ""
    print_status "Check logs to confirm checkpoint was saved:"
    echo "  journalctl -u $GPU_SERVICE -n 5 --no-pager"
}

cmd_kill() {
    local target="${1:-all}"
    local services=$(get_services "$target")
    
    print_warning "This will force kill without saving checkpoint!"
    read -p "Are you sure? (y/N) " -n 1 -r
    echo
    
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_status "Aborted"
        exit 0
    fi
    
    for service in $services; do
        print_status "Force killing $service..."
        if sudo systemctl kill --signal=SIGKILL "$service"; then
            print_success "$service killed"
        else
            print_error "Failed to kill $service"
        fi
    done
}

cmd_logs() {
    local target="${1:-all}"
    local services=$(get_services "$target")
    
    print_status "Following logs (Ctrl+C to exit)..."
    echo ""
    
    # Join services for journalctl
    local units=""
    for service in $services; do
        units="$units -u $service"
    done
    
    sudo journalctl $units -f
}

cmd_fresh() {
    CHECKPOINT_DIR="${CHECKPOINT_DIR:-checkpoints}"
    STATE_FILE="$CHECKPOINT_DIR/training_state.json"
    
    print_warning "This will reset training state for a fresh start."
    print_warning "Checkpoints will be preserved but training will restart from iteration 0."
    echo ""
    read -p "Are you sure? (y/N) " -n 1 -r
    echo
    
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_status "Aborted"
        exit 0
    fi
    
    if [ -f "$STATE_FILE" ]; then
        # Reset the state file
        cat > "$STATE_FILE" << EOF
{
  "iteration": 0,
  "total_games": 0,
  "total_train_steps": 0,
  "simulation_config": {},
  "best_avg_score": 0.0,
  "completed": false,
  "target_iterations": 0
}
EOF
        print_success "Training state reset"
        print_status "Next start will begin fresh training"
        print_status "To also reset model weights, use --no-auto-resume on GPU server"
    else
        print_warning "No training state file found at $STATE_FILE"
    fi
}

# Main
case "${1:-help}" in
    status)
        cmd_status
        ;;
    start)
        cmd_start "$2"
        ;;
    stop)
        cmd_stop "$2"
        ;;
    restart)
        cmd_restart "$2"
        ;;
    checkpoint|save)
        cmd_checkpoint "$2"
        ;;
    kill|force-stop)
        cmd_kill "$2"
        ;;
    logs|log)
        cmd_logs "$2"
        ;;
    fresh|reset)
        cmd_fresh
        ;;
    help|--help|-h)
        usage
        ;;
    *)
        print_error "Unknown command: $1"
        echo ""
        usage
        exit 1
        ;;
esac
